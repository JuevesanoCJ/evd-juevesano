<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Square Dino Runner</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
      background: #87CEEB;
      color: #333;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }
    canvas {
      display: block;
      border: 2px solid #333;
      border-radius: 10px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }
    #gameInfo {
      position: absolute;
      top: 20px;
      left: 20px;
      font-size: 20px;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(255,255,255,0.8);
    }
    #instructions {
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 14px;
      text-align: right;
      text-shadow: 1px 1px 2px rgba(255,255,255,0.8);
    }
  </style>
</head>
<body>

<div id="gameInfo">
  <div>Score: <span id="score">0</span></div>
  <div>High Score: <span id="highScore">0</span></div>
</div>

<div id="instructions">
  <div>Hold SPACE or ↑ to Fly</div>
  <div>↓ to Duck</div>
  <div>CLICK to Shoot</div>
  <div>R to Restart when Game Over</div>
</div>

<canvas id="gameCanvas" width="900" height="400"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Game state
let gameRunning = false;
let gameOver = false;
let score = 0;
let highScore = parseInt(localStorage.getItem('dinoHighScore') || '0');
let gameSpeed = 6;
let frameCount = 0;
let animationId;

// Player (Square Dino)
let dino = {
  x: 80,
  y: canvas.height - 100,
  width: 40,
  height: 40,
  color: '#228B22',
  vy: 0,
  onGround: true,
  isDucking: false,
  normalHeight: 40,
  duckHeight: 20,
  isFlying: false
};

// Game objects
let obstacles = [];
let particles = [];
let bullets = [];

// Constants
const gravity = 0.8;
const jumpStrength = -16;
const groundLevel = canvas.height - 60;
const bulletSpeed = 12;
const flyForce = -0.6;

// Input handling
let keys = {};
let jumpHeld = false;

document.addEventListener('keydown', (e) => {
  keys[e.code] = true;
  
  if ((e.code === 'Space' || e.code === 'ArrowUp') && !gameRunning && !gameOver) {
    startGame();
  }
  
  if ((e.code === 'Space' || e.code === 'ArrowUp') && gameRunning) {
    if (!jumpHeld && dino.onGround) {
      jump();
    }
    jumpHeld = true;
    dino.isFlying = true;
  }
  
  if (e.code === 'ArrowDown' && gameRunning) {
    duck();
  }
  
  if (e.code === 'KeyR' && gameOver) {
    resetGame();
  }
  
  e.preventDefault();
});

document.addEventListener('keyup', (e) => {
  keys[e.code] = false;
  
  if (e.code === 'Space' || e.code === 'ArrowUp') {
    jumpHeld = false;
    dino.isFlying = false;
  }
  
  if (e.code === 'ArrowDown') {
    stopDuck();
  }
});

// Mouse shooting
document.addEventListener('mousedown', (e) => {
  if (gameRunning) {
    shoot();
  }
});

// Game functions
function startGame() {
  gameRunning = true;
  gameOver = false;
  score = 0;
  gameSpeed = 6; // Always start fresh with speed 6!
  frameCount = 0;
  obstacles = [];
  particles = [];
  bullets = [];
  dino.y = groundLevel;
  dino.vy = 0;
  dino.onGround = true;
  dino.isDucking = false;
  dino.height = dino.normalHeight;
  dino.isFlying = false;
  jumpHeld = false;
}

function jump() {
  if (dino.onGround) {
    dino.vy = jumpStrength;
    dino.onGround = false;
    createJumpParticles();
  }
}

function duck() {
  if (dino.onGround) {
    dino.isDucking = true;
    dino.height = dino.duckHeight;
    dino.y = groundLevel + (dino.normalHeight - dino.duckHeight);
  }
}

function stopDuck() {
  dino.isDucking = false;
  dino.height = dino.normalHeight;
  dino.y = groundLevel;
}

function shoot() {
  bullets.push({
    x: dino.x + dino.width,
    y: dino.y + dino.height / 2,
    width: 8,
    height: 4,
    color: '#FFD700',
    speed: bulletSpeed
  });
  
  // Create muzzle flash particles
  for (let i = 0; i < 3; i++) {
    particles.push({
      x: dino.x + dino.width + Math.random() * 10,
      y: dino.y + dino.height / 2 + (Math.random() - 0.5) * 10,
      vx: Math.random() * 3 + 2,
      vy: (Math.random() - 0.5) * 4,
      life: 10,
      maxLife: 10,
      color: '#FFD700'
    });
  }
}

function createJumpParticles() {
  for (let i = 0; i < 5; i++) {
    particles.push({
      x: dino.x + Math.random() * dino.width,
      y: groundLevel + dino.normalHeight,
      vx: (Math.random() - 0.5) * 4,
      vy: Math.random() * -3 - 1,
      life: 20,
      maxLife: 20,
      color: '#8B4513'
    });
  }
}

function spawnObstacle() {
  const obstacleTypes = [
    // Cactus (rectangle)
    { width: 20, height: 40, color: '#228B22', shape: 'rect' },
    // Rock (circle)
    { width: 30, height: 30, color: '#696969', shape: 'circle' },
    // Tall cactus
    { width: 15, height: 60, color: '#32CD32', shape: 'rect' },
    // Flying bird (triangle)
    { width: 25, height: 15, color: '#4B0082', shape: 'triangle', flying: true }
  ];
  
  const type = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
  
  obstacles.push({
    x: canvas.width + 50,
    y: type.flying ? groundLevel - 80 + Math.random() * 40 : groundLevel + dino.normalHeight - type.height,
    width: type.width,
    height: type.height,
    color: type.color,
    shape: type.shape,
    flying: type.flying || false,
    hits: 0,
    maxHits: 5,
    originalColor: type.color
  });
}

function updateDino() {
  // Apply flying force whenholding jump
  if (dino.isFlying && jumpHeld) {
    dino.vy += flyForce;
  } else {
    // Apply gravity
    dino.vy += gravity;
  }
  
  dino.y += dino.vy;
  
  // Keep dino above top of screen
  if (dino.y < 0) {
    dino.y = 0;
    dino.vy = 0;
  }
  
  // Check ground collision
  if (dino.y >= groundLevel) {
    dino.y = groundLevel;
    dino.vy = 0;
    if (!dino.onGround) {
      createJumpParticles();
    }
    dino.onGround = true;
  } else {
    dino.onGround = false;
  }
}

function updateObstacles() {
  // Move obstacles
  obstacles.forEach(obstacle => {
    obstacle.x -= gameSpeed;
  });
  
  // Remove off-screen obstacles
  obstacles = obstacles.filter(obstacle => obstacle.x + obstacle.width > 0);
  
  // Spawn new obstacles
  if (frameCount % Math.max(60 - Math.floor(score / 100) * 5, 30) === 0) {
    spawnObstacle();
  }
}

function updateBullets() {
  // Move bullets
  bullets.forEach(bullet => {
    bullet.x += bullet.speed;
  });
  
  // Remove off-screen bullets
  bullets = bullets.filter(bullet => bullet.x < canvas.width + 50);
}

function updateParticles() {
  particles.forEach(particle => {
    particle.x += particle.vx;
    particle.y += particle.vy;
    particle.vy += 0.3; // Gravity on particles
    particle.life--;
  });
  
  particles = particles.filter(particle => particle.life > 0);
}

function checkBulletCollisions() {
  for (let bulletIndex = bullets.length - 1; bulletIndex >= 0; bulletIndex--) {
    const bullet = bullets[bulletIndex];
    
    for (let obstacleIndex = obstacles.length - 1; obstacleIndex >= 0; obstacleIndex--) {
      const obstacle = obstacles[obstacleIndex];
      
      if (bullet.x < obstacle.x + obstacle.width &&
          bullet.x + bullet.width > obstacle.x &&
          bullet.y < obstacle.y + obstacle.height &&
          bullet.y + bullet.height > obstacle.y) {
        
        // Remove bullet
        bullets.splice(bulletIndex, 1);
        
        // Hit obstacle
        obstacle.hits++;
        
        // Create hit particles
        for (let i = 0; i < 5; i++) {
          particles.push({
            x: obstacle.x + obstacle.width / 2 + (Math.random() - 0.5) * 20,
            y: obstacle.y + obstacle.height / 2 + (Math.random() - 0.5) * 20,
            vx: (Math.random() - 0.5) * 6,
            vy: (Math.random() - 0.5) * 6,
            life: 15,
            maxLife: 15,
            color: '#FF4500'
          });
        }
        
        // Destroy obstacle after 10 hits
        if (obstacle.hits >= obstacle.maxHits) {
          obstacles.splice(obstacleIndex, 1);
          score += 5; // Bonus points for destroying obstacles
          document.getElementById('score').textContent = score;
          
          // Create destruction particles
          for (let i = 0; i < 10; i++) {
            particles.push({
              x: obstacle.x + obstacle.width / 2,
              y: obstacle.y + obstacle.height / 2,
              vx: (Math.random() - 0.5) * 8,
              vy: (Math.random() - 0.5) * 8,
              life: 25,
              maxLife: 25,
              color: obstacle.originalColor
            });
          }
        }
        break; // Exit inner loop since bullet is destroyed
      }
    }
  }
}

function checkCollisions() {
  for (let i = 0; i < obstacles.length; i++) {
    const obstacle = obstacles[i];
    if (dino.x < obstacle.x + obstacle.width &&
        dino.x + dino.width > obstacle.x &&
        dino.y < obstacle.y + obstacle.height &&
        dino.y + dino.height > obstacle.y) {
      gameOver = true;
      gameRunning = false;
      
      // Reset game speed when game ends!
      gameSpeed = 6;
      
      // Update high score
      if (score > highScore) {
        highScore = score;
        localStorage.setItem('dinoHighScore', highScore.toString());
        document.getElementById('highScore').textContent = highScore;
      }
      break; // Exit loop once collision is detected
    }
  }
}

function updateScore() {
  if (gameRunning && frameCount % 6 === 0) {
    score++;
    document.getElementById('score').textContent = score;
    
    // Increase game speed gradually
    if (score % 100 === 0) {
      gameSpeed += 0.5;
    }
  }
}

function drawBackground() {
  // Sky blue background
  ctx.fillStyle = '#87CEEB';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
}

function drawGround() {
  // Brown ground
  ctx.fillStyle = '#8B4513';
  ctx.fillRect(0, groundLevel + dino.normalHeight, canvas.width, canvas.height);
}

function drawDino() {
  ctx.fillStyle = dino.color;
  ctx.fillRect(dino.x, dino.y, dino.width, dino.height);
  
  // Eyes
  ctx.fillStyle = 'white';
  ctx.fillRect(dino.x + 25, dino.y + 8, 8, 6);
  ctx.fillStyle = 'black';
  ctx.fillRect(dino.x + 27, dino.y + 10, 4, 2);
  
  // Add running animation
  if (dino.onGround && gameRunning && !dino.isDucking) {
    const legOffset = Math.sin(frameCount * 0.3) * 2;
    ctx.fillStyle = dino.color;
    ctx.fillRect(dino.x + 5, dino.y + dino.height, 8, 5 + legOffset);
    ctx.fillRect(dino.x + 25, dino.y + dino.height, 8, 5 - legOffset);
  }
}

function drawBullets() {
  bullets.forEach(bullet => {
    ctx.fillStyle = bullet.color;
    ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
    
    // Add bullet trail effect
    ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
    ctx.fillRect(bullet.x - 4, bullet.y - 1, bullet.width + 4, bullet.height + 2);
  });
}

function drawObstacles() {
  obstacles.forEach(obstacle => {
    ctx.fillStyle = obstacle.color;
    
    switch(obstacle.shape) {
      case 'rect':
        ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
        break;
      case 'circle':
        ctx.beginPath();
        ctx.arc(obstacle.x + obstacle.width/2, obstacle.y + obstacle.height/2, 
                obstacle.width/2, 0, 2 * Math.PI);
        ctx.fill();
        break;
      case 'triangle':
        ctx.beginPath();
        ctx.moveTo(obstacle.x + obstacle.width/2, obstacle.y);
        ctx.lineTo(obstacle.x, obstacle.y + obstacle.height);
        ctx.lineTo(obstacle.x + obstacle.width, obstacle.y + obstacle.height);
        ctx.closePath();
        ctx.fill();
        break;
    }
  });
}

function drawParticles() {
  particles.forEach(particle => {
    const alpha = particle.life / particle.maxLife;
    if (particle.color === '#8B4513') {
      ctx.fillStyle = `rgba(139, 69, 19, ${alpha})`;
    } else if (particle.color === '#FFD700') {
      ctx.fillStyle = `rgba(255, 215, 0, ${alpha})`;
    } else if (particle.color === '#FF4500') {
      ctx.fillStyle = `rgba(255, 69, 0, ${alpha})`;
    } else {
      // Use the particle's color with alpha
      const r = parseInt(particle.color.slice(1, 3), 16);
      const g = parseInt(particle.color.slice(3, 5), 16);
      const b = parseInt(particle.color.slice(5, 7), 16);
      ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }
    ctx.fillRect(particle.x, particle.y, 3, 3);
  });
}

function drawStartScreen() {
  ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  ctx.fillStyle = 'white';
  ctx.font = 'bold 36px Arial';
  ctx.textAlign = 'center';
  ctx.fillText('SQUARE DINO RUNNER', canvas.width/2, canvas.height/2 - 40);
  
  ctx.font = '24px Arial';
  ctx.fillText('Press SPACE or ↑ to Start', canvas.width/2, canvas.height/2 + 20);
  
  ctx.font = '16px Arial';
  ctx.fillText('Hold jump to fly! Click to shoot!', canvas.width/2, canvas.height/2 + 60);
}

function drawGameOver() {
  ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  ctx.fillStyle = 'white';
  ctx.font = 'bold 48px Arial';
  ctx.textAlign = 'center';
  ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2 - 40);
  
  ctx.font = '24px Arial';
  ctx.fillText(`Final Score: ${score}`, canvas.width/2, canvas.height/2 + 10);
  ctx.fillText(`High Score: ${highScore}`, canvas.width/2, canvas.height/2 + 40);
  
  ctx.font = '20px Arial';
  ctx.fillText('Press R to Restart', canvas.width/2, canvas.height/2 + 80);
}

function update() {
  frameCount++;
  
  if (gameRunning) {
    updateDino();
    updateObstacles();
    updateBullets();
    updateParticles();
    checkBulletCollisions();
    checkCollisions();
    updateScore();
  }
}

function draw() {
  drawBackground();
  drawGround();
  drawParticles();
  drawDino();
  drawBullets();
  drawObstacles();
  
  if (!gameRunning && !gameOver) {
    drawStartScreen();
  }
  
  if (gameOver) {
    drawGameOver();
  }
}

function gameLoop() {
  update();
  draw();
  animationId = requestAnimationFrame(gameLoop);
}

function resetGame() {
  // Stop the current game loop
  if (animationId) {
    cancelAnimationFrame(animationId);
  }
  
  gameOver = false;
  gameRunning = false;
  score = 0;
  jumpHeld = false;
  gameSpeed = 6; // Reset game speed!
  frameCount = 0;
  document.getElementById('score').textContent = score;
  
  // Start fresh game loop
  gameLoop();
}

// Initialize high score display
document.getElementById('highScore').textContent = highScore;

// Start the initial game loop
animationId = requestAnimationFrame(gameLoop);
</script>

</body>
</html>